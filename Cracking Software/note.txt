https://ikrima.dev/dev-notes/assembly/asm-cheatsheet/
https://www.cs.virginia.edu/~evans/cs216/guides/x86.html
https://trungkmare.wordpress.com/2018/05/31/bang-lenh-nhay-trong-assembly/
https://www.tutorialspoint.com/assembly_programming/assembly_logical_instructions.htm





https://www.asciitable.com/

msdn



- cấu trúc 1 function
push ebp
mov ebp,esp
....
leave
ret



- EAX: the primary accumulator
	eax thường được dùng để lưu kết quả của func call, operation or so sánh, lệnh jump đôi khi cũng dựa trên kết quả được lưu ở eax
- EBX: base register
- ECX: count register
- EDX: data register
- ESI,EDI thường được dùng để lưu trữ chuỗi
	ESI thường được dùng để lưu source string
	EDI thường được dùng để lưu điểm đến của string
- EIP là nơi lưu trữ địa chỉ của current instruction 
- ESP = top of the stack
  EBP = bottom of the stack




qword 8 bytes
dword 4 bytes
word 2 bytes





- mov dword ptr ds:["memory address"], eax
ds = data segment
ss = stack segment	(no goi o phan stack)

Code – The segment where actual code is stored and is represented by the .text section. It mainly contains assembly language instructions and can not be expanded once program execution begins.

Data – Represented by the .data and .bss sections, it is used to declare global and local variables. It remains static throughout the program.

Stack – In this memory segment, data may be initialized at run-time. It acts as temporary storage and follows the Last In First Out protocol, which means that elements are only added or removed from the top.






- flags
https://viblo.asia/p/toi-da-hoc-assembly-32bit-nhu-the-nao-phan-2-1Je5EmDG5nL
- ZF (zero flag)
	ZF = 1 khi kết quả tính toán = 0 hoặc phép so sánh bằng nhau
	ZF = 0 khi kết quả tính toán non-zero hoặc phép so sánh khác nhau

- CF (carry flag)
	https://viblo.asia/p/toi-da-hoc-assembly-32bit-nhu-the-nao-phan-2-1Je5EmDG5nL

- SF (sign flag)
	nó lấy bit đầu tiên của kết quả để biết được nó âm hay dương
	SF = 0 mean positive
	SF = 1 mean negative

- OF (overflow flag)
	OF = 1 khi kết quả của phép toán có dấu lớn hơn so với kích thước của địa chỉ đích hoặc phép tính sai

- DF (direction flag)
	this flag controls whether the string address increase or decrease after each string instruction
	DF = 0 mean EDI address increases after each string operation
	DF = 1 mean EDI address decreases after each string operation
	CLD will clear the DF flag (DF = 0)
	STD will set the DF flag (DF = 1)
	default DF = 0



- chúng ta nhìn vào CF và OF khi
	nếu chương trình dùng Unsigned Numbers thì ta tập trung vào CF flag
	nếu chương trình dùng Signed numbers thì ta tập trung vào OF flag

- Signed vs Unsigned Numbers
https://www.cs.uaf.edu/2008/fall/cs301/lecture/10_17_signed_unsigned.html













instructions
test eax,eax
je 0x11111
	check if eax = 0 then it will nhay
	tùy vào điều kiện jump mà lênh test có thể thay đổi 

test eax, eax  ; set SF to 1 if eax < 0 (negative)
js error ; jump if SF == 1














- lessons CSL
crackMe 2 - Cracking Registration File Checks
crackME 3 - Removing Nag Screens
crackme 4 - Cracking Trial Period Software - (important)
crackme 5 - Cracking Auto-Generated Serial Keys	- (important)
crackme 6 - Removing Nag Screen by TDC
crackme 7 - Cracking by patching eax register values
crackme 8 - Cracking via Hardware Breakpoints
crackme 9 - How to Change Serial Key By Patching Memory Directly - (important)
crackme 10 - Serial Fishing - how to extract serial key - (important)




- user code usually 0040000...
- operating system code usually 007000..
- address start with 7 thì chúng ta đang ở operating system memory address
	VD 743D6879 bắt đầu với 7
	đây là nơi chúng ta k cần xem



- tìm good message or bad message sau đó tìm hàm window gần nhất và đặt BP
- xor eax,eax
	lệnh này dùng để clear thanh ghi vì ta set eax về 0
	https://www.tutorialspoint.com/assembly_programming/assembly_logical_instructions.htm


- set BP on strings
- set BP on intermodular calls
- set BP from call stack

- đầu tiền chúng ta tìm bad message 
	- sau đó ta theo dõi lệnh jump kiểm tra vì sao nó nhảy tới bad message
	- sau đó chúng ta nhìn vào eax xem nó bằng fffffff hay 00000000 
		- nếu là 00000000 thì kết quả đang đúng
		- nếu là ffffffff thì kết quả đang sai và chúng ta cần theo dõi eax phía trên để tìm tại sao nó lại ffffffff từ đó ta có thể sửa đổi giá trị hoặc tìm ra password để nhảy tới good message
			- khi ta tìm ra 1 register so sanh khiến nó thành ffffffff mà không có sự so sánh chuỗi hay đọc file .... thì ta chỉ cần sửa lệnh tới good message vì nó sẽ không ảnh hưởng đến chức năng
			- khi ta tìm ra 1 func hay 1 sự so sánh thì ta có thể vào mà check và có thể extract password
			- nếu đó là func của window api ta cần check document để xem nó trả về cái gì và xử lý tiếp






- ReadFile window API
	+ dữ liệu của file sẽ được lưu ở địa tri với biến lpNumberOfBytesRead
	+ nNumberOfBytesToRead : The maximum number of bytes to be read.




