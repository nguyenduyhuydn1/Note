https://ikrima.dev/dev-notes/assembly/asm-cheatsheet/
https://www.cs.virginia.edu/~evans/cs216/guides/x86.html
https://trungkmare.wordpress.com/2018/05/31/bang-lenh-nhay-trong-assembly/
https://www.tutorialspoint.com/assembly_programming/assembly_logical_instructions.htm





https://www.asciitable.com/

msdn



- cấu trúc 1 function
push ebp
mov ebp,esp
....
leave
ret



- EAX: the primary accumulator
	eax thường được dùng để lưu kết quả của func call, operation or so sánh, lệnh jump đôi khi cũng dựa trên kết quả được lưu ở eax
- EBX: base register
- ECX: count register
- EDX: data register
- ESI,EDI thường được dùng để lưu trữ chuỗi
	ESI thường được dùng để lưu source string
	EDI thường được dùng để lưu điểm đến của string
- EIP là nơi lưu trữ địa chỉ của current instruction 
- ESP = top of the stack
  EBP = bottom of the stack




qword 8 bytes
dword 4 bytes
word 2 bytes





- mov dword ptr ds:["memory address"], eax
ds = data segment
ss = stack segment	(no goi o phan stack)

Code – The segment where actual code is stored and is represented by the .text section. It mainly contains assembly language instructions and can not be expanded once program execution begins.

Data – Represented by the .data and .bss sections, it is used to declare global and local variables. It remains static throughout the program.

Stack – In this memory segment, data may be initialized at run-time. It acts as temporary storage and follows the Last In First Out protocol, which means that elements are only added or removed from the top.






- flags
https://viblo.asia/p/toi-da-hoc-assembly-32bit-nhu-the-nao-phan-2-1Je5EmDG5nL
- ZF (zero flag)
	ZF = 1 khi kết quả tính toán = 0 hoặc phép so sánh bằng nhau
	ZF = 0 khi kết quả tính toán non-zero hoặc phép so sánh khác nhau

- CF (carry flag)
	https://viblo.asia/p/toi-da-hoc-assembly-32bit-nhu-the-nao-phan-2-1Je5EmDG5nL

- SF (sign flag)
	nó lấy bit đầu tiên của kết quả để biết được nó âm hay dương
	SF = 0 mean positive
	SF = 1 mean negative

- OF (overflow flag)
	OF = 1 khi kết quả của phép toán có dấu lớn hơn so với kích thước của địa chỉ đích hoặc phép tính sai

- DF (direction flag)
	this flag controls whether the string address increase or decrease after each string instruction
	DF = 0 mean EDI address increases after each string operation
	DF = 1 mean EDI address decreases after each string operation
	CLD will clear the DF flag (DF = 0)
	STD will set the DF flag (DF = 1)
	default DF = 0



- chúng ta nhìn vào CF và OF khi
	nếu chương trình dùng Unsigned Numbers thì ta tập trung vào CF flag
	nếu chương trình dùng Signed numbers thì ta tập trung vào OF flag

- Signed vs Unsigned Numbers
https://www.cs.uaf.edu/2008/fall/cs301/lecture/10_17_signed_unsigned.html













instructions
test eax,eax
je 0x11111
	check if eax = 0 then it will nhay
	tùy vào điều kiện jump mà lênh test có thể thay đổi 

test eax, eax  ; set SF to 1 if eax < 0 (negative)
js error ; jump if SF == 1

















method crack
- set BP on strings
	+ keyword for search
		+ LICENSE
		+ REGISTER
		+ activate
		+ check
- set BP on intermodular calls
	+ tìm các fx api window trong dự án
- set BP from call stack
	+ isDebuggerPresent bypass, attach software is running
	+ symbols -> name.exe (đưa đến entr point) -> run -> nhấn nhập key và hiện thông báo lỗi -> pause -> call stack -> user module cai hiện thông báo lỗi -> execute till return -> nếu là system module thì ta bấm run to user code || user module thì t check func(end) -> nhấn ok thông báo lỗi -> check func (end)
		- mục đích của việc này là để bắt đc con trỏ lệnh đang chạy ở đâu
		- ví dụ khi ta chạy run hiển thị giao diện ứng dụng ---> bấm vào nhập key thì lệnh sẽ chạy tới nhập key ---> khi ta nhập key và ok thì lệnh nó chạy tới thông báo , việc ta thược hiện thao tác till to return nhằm chạy tới nơi mà giao diện đang hiển thị và thực hiện run to user code tới nơi mà người dùng bấm để đi tiếp.
- call stack xref method
	+ coi 048 call stack xref method cps
	+ show nơi gọi hàm này
- waitMessage API method = onion method = coming out of the inner calls layer by layer
	+ 079 WaitMessage API	CSP
	+ 082 onion method - chuan hon cai 79
	+ waitmessage api la phản hồi cho việc chờ người dùng tương tác vơi window, vd: click button
	+ hình như chỉ sử lí nag screen hoặc cho việc loop check sự kiên ....
	+ chủ yêu dùng để remove nag screen nơi có chức năng load khiến gây vấn đề khi debug chắc vậy
	+ chức năng này giúp ta đi từ layer đầu đến layer 2 ... rồi  tới nơi t cân crack, khi ta tới nơi có nhiều code nhất trong func, có nhiều func lồng , nhiều string khả năng là cái ta cần crack





- lessons CSL
crackMe 2 - Cracking Registration File Checks
crackME 3 - Removing Nag Screens
crackme 4 - Cracking Trial Period Software - (important)
crackme 5 - Cracking Auto-Generated Serial Keys	- (important)
crackme 6 - Removing Nag Screen by TDC
crackme 7 - Cracking by patching eax register values
crackme 8 - Cracking via Hardware Breakpoints
crackme 9 - How to Change Serial Key By Patching Memory Directly - (important)
crackme 10 - Serial Fishing - how to extract serial key - (important)
crackme 11 - Cracking Software Protection - (important)
crackme 12 - Cracking software using loaders - (important)
crackme 13 - Cracking Software's Anti-Debugging Protection - (important)
crackme 13 - Cracking Software that has a combination of Packing + Anti-Debugging - (super important)


- user code usually 0040000...
- operating system code usually 007000..
- address start with 7 thì chúng ta đang ở operating system memory address
	VD 743D6879 bắt đầu với 7
	đây là nơi chúng ta k cần xem

- tìm good message or bad message sau đó tìm hàm window gần nhất và đặt BP
- xor eax,eax
	lệnh này dùng để clear thanh ghi vì ta set eax về 0
	https://www.tutorialspoint.com/assembly_programming/assembly_logical_instructions.htm

- đầu tiền chúng ta tìm bad message 
	- sau đó ta theo dõi lệnh jump kiểm tra vì sao nó nhảy tới bad message
	- sau đó chúng ta nhìn vào eax xem nó bằng fffffff hay 00000000 
		- nếu là 00000000 thì kết quả đang đúng
		- nếu là ffffffff thì kết quả đang sai và chúng ta cần theo dõi eax phía trên để tìm tại sao nó lại ffffffff từ đó ta có thể sửa đổi giá trị hoặc tìm ra password để nhảy tới good message
			- khi ta tìm ra 1 register so sanh khiến nó thành ffffffff mà không có sự so sánh chuỗi hay đọc file .... thì ta chỉ cần sửa lệnh tới good message vì nó sẽ không ảnh hưởng đến chức năng
			- khi ta tìm ra 1 func hay 1 sự so sánh thì ta có thể vào mà check và có thể extract password
			- nếu đó là func của window api ta cần check document để xem nó trả về cái gì và xử lý tiếp







- lessons CSP
017 installing vsd  - (important)
023 cracking mr bills  - (important)
029 cracking registry checks  - (super important)
033 removing nag
042 deep patching step into calls
048 call stack xref method - (super important)
055 themida and resource hacker - (super important)  	cach dung resource hacker	giong deep free
058 deep patch with call stack - (super important)
059 installing intelligent shutdown - hoc cach scan tim protecter
061 call stack deep patching - (super important)
062 bypass crc - (super important) multiple check
068 crack registration form  - (super important)
073 patching setwindowtext api - set BP on intermodular calls
073 1 cracking registration scheme - x64 crack license
079 WaitMessage API - what a fucking trick, very very important
083 remove trial - very very important
082 onion method - very very important
084 remove print watermark - resource hacker
086 tracing rsp memory	- cẩn thận lỗi khi đặt BP kiểu đặt quá cao khiến k bắt đc popup mình cần
089 bypassing anti tamper - trick dll file
090 registering the program - crack dll file , rat quang trong
091 removing activation button - hieu cach xoa form trong .net
098 bypassing server checks - same deep freeze, can ban la no tranh man hinh login
100 bypass expired trial nag - same 098, cung xoa login chu khong tim cach vao tim key
102 GetLocalTime API - bypass time 
108 dnspy call stack and http analyzer method - .net
110 crack license check - .net
112 crack login password - .net
115 unpacking themida protection - crack themida , trick use detect it easy (.Net) cần phần mềm để fix dump coi để biết
118 getlocaltime api - internalmodular
120 blocking server checks - block server check, cung co the nop ham call server check
124 setting software to Genuine and Activating program features - .Net
126 bypass server response method - .Net
128 isDebuggerPresent bypass install and crack - kha la ao coi ki








- 1-55 se co bai` hoc dung set breakpoint on execution lo ma tim thang ngu
	+ (chua chac lo ma tim) set breakpoint on execution : set khi chuong trinh dang running, neu ta set breakpoint thuong thi ta k the step over duoc nhung khi set breakpoint on execution thi co the

- khi chúng ta đang tìm đường đi để check thì chúng ta phãi coi cái ram memory address (địa chỉ chạy lệnh)
	- khi chúng ta đang check bằng cách nhấn f8 thì đôi khi nó sẽ hiện running nhưng k thể thao tác , đó là lý do ta dùng hardware breakpoint
	- khi ta tìm ở ram memory address 6xxxxx.... mà chuyển tới address hệ thống 8xxx thì nên dừng ở hàm gọi gần nhất và press g để check các đường đi
	- 6xxxxxx... là thư viện  chúng ta có thể check ở memory map
	- thống thường là ta tìm ở phần code user 4xxxxx..
	- https://www.youtube.com/watch?v=D9hQu9fAmCs&list=PLFgDJNQkgnu9NilH9vjHtJC0mW4o7jegn&index=18&pp=gAQBiAQBsAQB
	
- tín hiệu ta đang debug đúng nơi là có nhiều jump và register thường là các thanh ghi tính toán eax ebx,esi .....
- thường thì đường đi ngắn nhất là sai
- khi đã crack chúng ta phãi đổi tên file về như củ vì có khả năng sẽ sinh lỗi vì các chức năng cần check name file để sử dụng :V trick lừa mấy ông debugger
- trick để trả về đúng giá trị là thay cả func đó với lệnh ta cần
	+ VD:   call 0x11412
		cmp eax,1
		je 0x11111
	+ ta cần eax = 1 và gọi hàm phãi trả về 1, thì ta chỉ cần sử cái hàm đấy  trả về 1 
		mov eax,1
		ret
		+ điều này giúp ta bypass mọi nơi mỗi khi call hàm này để check nó đều trả về 1
- trick xử lý crack
	+ nếu so sánh là ở bộ nhớ chúng ta nên vào hàm và xem giá trị nào thay đổi bộ nhớ đấy
		+ vì các giá trị dưỡi sẽ trích xuất dữ liệu từ bộ nhớ ra so sánh nên ta phãi vào hàm coi kĩ và sửa giá trị sao cho hợp lý
	+ nêu so sánh nhảy là thanh ghi với thanh ghi và số thì chúng ta sẽ kiếm hàm thay đổi trả về giá trị hoặc sửa jmp luôn cũng dc, đôi khi chúng ta vẫn nên kiểm tra vì kiểu j đoạn sau có thể check lại thanh ghi
		









mô phỏng
- để crack clear (crack toàn bộ mà k phãi từng phần) chúng ta phãi tìm cái register khiến chúng ta có bad message và sau đó tìm các lệnh khiến cho register đó thay đổi
	023 cracking mr bills  - (important)
- thông thường programer sẽ
	check format -> check value


- mổ ta deep crack
	+ họ sẽ tạo 1 hoặc nhiều func check và dùng lại nhiều lần
	+ nếu chúng ta crack surface thì chúng ta chỉ thay đổi giá trị check và dẫn dắt tới good message nhưng nêu chúng ta muốn deep crack chúng ta phãi đi qua phần check của nó và xem, khi chúng ta sửa thành công thì chúng ta sẽ crack toàn bộ mà không cần sửa các chức năng khác


try it
https://reverseengineering.stackexchange.com/questions/2796/find-a-string-that-i-entered-in-ollydbg


or al,1		- 2byte








Burp Suite
deep freeze
https://www.softwaretestinghelp.com/remote-access-software/





- ReadFile window API
	+ dữ liệu của file sẽ được lưu ở địa tri với biến lpNumberOfBytesRead
	+ nNumberOfBytesToRead : The maximum number of bytes to be read.



- .NET Deobfuscator
https://github.com/NotPrab/.NET-Deobfuscator
https://github.com/Patrick979/.NET-Deobfuscator
	- confuser 1.9
		+ de4dot
	- confuserex
		
			



