https://ikrima.dev/dev-notes/assembly/asm-cheatsheet/
https://www.cs.virginia.edu/~evans/cs216/guides/x86.html
https://trungkmare.wordpress.com/2018/05/31/bang-lenh-nhay-trong-assembly/
https://www.tutorialspoint.com/assembly_programming/assembly_logical_instructions.htm





https://www.asciitable.com/

msdn



- cấu trúc 1 function
push ebp
mov ebp,esp
....
leave
ret
- nếu là chương trình 64bit thì ta theo dõi push rbp, push rbx, push rsp







- EAX: the primary accumulator
	eax thường được dùng để lưu kết quả của func call, operation or so sánh, lệnh jump đôi khi cũng dựa trên kết quả được lưu ở eax
- EBX: base register
- ECX: count register
- EDX: data register
- ESI,EDI thường được dùng để lưu trữ chuỗi
	ESI thường được dùng để lưu source string
	EDI thường được dùng để lưu điểm đến của string
- EIP là nơi lưu trữ địa chỉ của current instruction 
- ESP = top of the stack
  EBP = bottom of the stack




qword 8 bytes
dword 4 bytes
word 2 bytes





- mov dword ptr ds:["memory address"], eax
ds = data segment
ss = stack segment	(no goi o phan stack)

Code – The segment where actual code is stored and is represented by the .text section. It mainly contains assembly language instructions and can not be expanded once program execution begins.

Data – Represented by the .data and .bss sections, it is used to declare global and local variables. It remains static throughout the program.

Stack – In this memory segment, data may be initialized at run-time. It acts as temporary storage and follows the Last In First Out protocol, which means that elements are only added or removed from the top.






- flags
https://viblo.asia/p/toi-da-hoc-assembly-32bit-nhu-the-nao-phan-2-1Je5EmDG5nL
- ZF (zero flag)
	ZF = 1 khi kết quả tính toán = 0 hoặc phép so sánh bằng nhau
	ZF = 0 khi kết quả tính toán non-zero hoặc phép so sánh khác nhau

- CF (carry flag)
	https://viblo.asia/p/toi-da-hoc-assembly-32bit-nhu-the-nao-phan-2-1Je5EmDG5nL

- SF (sign flag)
	nó lấy bit đầu tiên của kết quả để biết được nó âm hay dương
	SF = 0 mean positive
	SF = 1 mean negative

- OF (overflow flag)
	OF = 1 khi kết quả của phép toán có dấu lớn hơn so với kích thước của địa chỉ đích hoặc phép tính sai

- DF (direction flag)
	this flag controls whether the string address increase or decrease after each string instruction
	DF = 0 mean EDI address increases after each string operation
	DF = 1 mean EDI address decreases after each string operation
	CLD will clear the DF flag (DF = 0)
	STD will set the DF flag (DF = 1)
	default DF = 0



- chúng ta nhìn vào CF và OF khi
	nếu chương trình dùng Unsigned Numbers thì ta tập trung vào CF flag
	nếu chương trình dùng Signed numbers thì ta tập trung vào OF flag

- Signed vs Unsigned Numbers
https://www.cs.uaf.edu/2008/fall/cs301/lecture/10_17_signed_unsigned.html













instructions
test eax,eax
je 0x11111
	check if eax = 0 then it will nhay
	tùy vào điều kiện jump mà lênh test có thể thay đổi 

test eax, eax  ; set SF to 1 if eax < 0 (negative)
js error ; jump if SF == 1

















method crack
- set BP on strings
	+ keyword for search
		+ LICENSE
		+ REGISTER
		+ activate
		+ check
- set BP on intermodular calls
	+ tìm các fx api window trong dự án
- set BP from call stack
	+ isDebuggerPresent bypass, attach software is running
	+ symbols -> name.exe (đưa đến entr point) -> run -> nhấn nhập key và hiện thông báo lỗi -> pause -> call stack -> user module cai hiện thông báo lỗi -> execute till return -> nếu là system module thì ta bấm run to user code || user module thì t check func(end) -> nhấn ok thông báo lỗi -> check func (end)
		- mục đích của việc này là để bắt đc con trỏ lệnh đang chạy ở đâu
		- ví dụ khi ta chạy run hiển thị giao diện ứng dụng ---> bấm vào nhập key thì lệnh sẽ chạy tới nhập key ---> khi ta nhập key và ok thì lệnh nó chạy tới thông báo , việc ta thược hiện thao tác till to return nhằm chạy tới nơi mà giao diện đang hiển thị và thực hiện run to user code tới nơi mà người dùng bấm để đi tiếp.
	+ trick
		+ khi ta dùng call stack mà nhiều hàm chạy thì ta check từng cái
		+ nếu nó vừa chạy qua getmessage thì sai vì software nó thông báo lỗi khi nhập key nên k có vụ mới chạy nhận được
		+ nếu hàm thông báo nó lại show trước khi chạy nhánh là sai vì k có nhận sao lại thông báo mà còn chạy chia nhánh
		+ trước tiên là tick hết các mục rồi chạy lại cho nhanh


- call stack xref method
	+ coi 048 call stack xref method cps
	+ show nơi gọi hàm này
- waitMessage API method 
	+ 079 WaitMessage API	CSP
	+ 082 onion method - chuan hon cai 79
	+ waitmessage api la phản hồi cho việc chờ người dùng tương tác vơi window, vd: click button
	+ hình như chỉ sử lí nag screen hoặc cho việc loop check sự kiên ....
	+ chủ yêu dùng để remove nag screen nơi có chức năng load khiến gây vấn đề khi debug chắc vậy
	+ chức năng này giúp ta đi từ layer đầu đến layer 2 ... rồi  tới nơi t cân crack, khi ta tới nơi có nhiều code nhất trong func, có nhiều func lồng , nhiều string khả năng là cái ta cần crack
- onion method = coming out of the inner calls layer by layer
	+ func trong func
	+ chung ta can di ra khoi func hien tại để tới thằng cha
- baseline trace = to see default path
	+ thuật ngữ theo theo dõi dấu vết cơ bản 
	+ trace record
- message breakpoint method
	+ xử lý sự kiện click
	+ vd: khi chúng ta click vào nút ok
- handles
	+ 136 prevent force close
- new method, crack tu viec check software lưu key và đọc key dung api monitor
	+ theo dõi no đọc key ở file nào, ta tìm cach crack khiến key confirm
	+ se crack all chuc nang khi dung ki thuat nay
	+ 164 tracing key file
	+ 184 GetPrivateProfileString API
	+ 186 TracingGlobalVariables
- data segment analysis
- lam the nao de phan tich deep debug
	+ 172 using exceptions to locate patch - chuan 
	+ 186 TracingGlobalVariables
- diff tracing method
	+khi trials cho dùng full chức năng nhưng có giới hạn ta có thể dùng method này để crack
		+ 187 diff tracing and GetSystemTimeAsFileTimeAPI
		+ đây là api theo dĩu tune hệ thống thay đổi nó và đồng thời crack full thời gian dùng trials

- 189 comment tracing method
	+ cẩn thận các giá trị global khi crack nhánh

- unpack 
	+ 137 pushebp unpacking method - unpack upx method 1
		- dùng trường hợp này khi bạn muốn dump exe file và crack nó
		- nếu chúng ta cứ cưỡng chế crack mà không dump thì nó sẽ tạo junk code ( code rác ) vì nó chưa unpack
	+ 139 virtualalloc virtualprotect unpacking method - unpacking method method 2
		- dùng khi bạn muốn dung cheat engine để crack, nó giúp tìm đc nơi đã unpack và ta có thể đặt bp ở đó để crack, cụ thể là virtualalloc nó sẽ cấp bộ nhớ và thằng virtualprotect sẽ cấp quyền việc dùng  method này giúp ta lấy được nơi unpack và thao tác với nó. không cần dump exe file và có thể dùng cheat engine để crack

- các cách protect software
	+ crackme 11 - Cracking Software Protection - (important) (CSL)
	+ crackme 11 - Cracking Software Protection - (important) (CSL)
	
	+ 062 bypass crc - (super important) multiple check (CSP)
	+ 089 bypassing anti tamper - trick dll file, anti tamper khong dung timer
	+ 098 bypassing server checks - same deep freeze, can ban la no tranh man hinh login
	+ 102 GetLocalTime API - bypass time 
	+ 128 isDebuggerPresent bypass install and crack - kha la ao coi ki
	+ 135 bypass anti tamper - new method co dung timer, phãi dùng internalmodular dùng settimer api để xử lý
	+ 151 process explorer and disabled buttons (CSP) - loadder
	+ 153 bypass loader protection - ************************* quang trong vcc (CSP)
	+ 158 bypassing turbo activate - bypass turboactivate.exe toi coi toi eo biet no bypass cho nao
	+ 223 bypassing vmprotect kernel level anti debug protection














luu y, mau chot de crack any software du kho kieu loz j di nua
Every windows message (events) goes into a message loop that contains two functions:
TranslateMessage()
	https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage
DispatchMessage()
	https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessage
	+ DispatchMessage() sẽ gửi windowsmessage to the callback func
	+ sẽ gửi 1 windowmessage đến the callback func
window message
	+ https://learn.microsoft.com/en-us/windows/win32/learnwin32/window-messages

virtualalloc is api for allocating memory for writing. virtualprotect is api for changing a memory region to read, wirte or execute




- lessons CSL
crackMe 2 - Cracking Registration File Checks
crackME 3 - Removing Nag Screens
crackme 4 - Cracking Trial Period Software - (important)
crackme 5 - Cracking Auto-Generated Serial Keys	- (important)
crackme 6 - Removing Nag Screen by TDC
crackme 7 - Cracking by patching eax register values
crackme 8 - Cracking via Hardware Breakpoints
crackme 9 - How to Change Serial Key By Patching Memory Directly - (important)
crackme 10 - Serial Fishing - how to extract serial key - (important)
crackme 11 - Cracking Software Protection - (important)
crackme 12 - Cracking software using loaders - (important)
crackme 13 - Cracking Software's Anti-Debugging Protection - (important)
crackme 13 - Cracking Software that has a combination of Packing + Anti-Debugging - (super important)


- user code usually 0040000...
- operating system code usually 007000..
- address start with 7 thì chúng ta đang ở operating system memory address
	VD 743D6879 bắt đầu với 7
	đây là nơi chúng ta k cần xem

- tìm good message or bad message sau đó tìm hàm window gần nhất và đặt BP
- xor eax,eax
	lệnh này dùng để clear thanh ghi vì ta set eax về 0
	https://www.tutorialspoint.com/assembly_programming/assembly_logical_instructions.htm

- đầu tiền chúng ta tìm bad message 
	- sau đó ta theo dõi lệnh jump kiểm tra vì sao nó nhảy tới bad message
	- sau đó chúng ta nhìn vào eax xem nó bằng fffffff hay 00000000 ( con dua vao gia tri so sanh)
		- nếu là 00000000 thì kết quả đang đúng
		- nếu là ffffffff thì kết quả đang sai và chúng ta cần theo dõi eax phía trên để tìm tại sao nó lại ffffffff từ đó ta có thể sửa đổi giá trị hoặc tìm ra password để nhảy tới good message
			- khi ta tìm ra 1 register so sanh khiến nó thành ffffffff mà không có sự so sánh chuỗi hay đọc file .... thì ta chỉ cần sửa lệnh tới good message vì nó sẽ không ảnh hưởng đến chức năng
			- khi ta tìm ra 1 func hay 1 sự so sánh thì ta có thể vào mà check và có thể extract password
			- nếu đó là func của window api ta cần check document để xem nó trả về cái gì và xử lý tiếp

			- 172 using exceptions to locate patch tham khao, phan tich deep debug





- lessons CSP
017 installing vsd  - (important)
023 cracking mr bills  - (important)
029 cracking registry checks  - (super important)
033 removing nag
042 deep patching step into calls
048 call stack xref method - (super important)
055 themida and resource hacker - (super important)  	cach dung resource hacker	giong deep free
058 deep patch with call stack - (super important)
059 installing intelligent shutdown - hoc cach scan tim protecter
061 call stack deep patching - (super important)

068 crack registration form  - (super important)
073 patching setwindowtext api - set BP on intermodular calls
073 1 cracking registration scheme - x64 crack license
079 WaitMessage API - what a fucking trick, very very important
083 remove trial - very very important
082 onion method - very very important
084 remove print watermark - resource hacker
086 tracing rsp memory	- cẩn thận lỗi khi đặt BP kiểu đặt quá cao khiến k bắt đc popup mình cần

090 registering the program - crack dll file , rat quang trong
091 removing activation button - hieu cach xoa form trong .net

100 bypass expired trial nag - same 098, cung xoa login chu khong tim cach vao tim key

108 dnspy call stack and http analyzer method - .net
110 crack license check - .net
112 crack login password - .net
115 unpacking themida protection - crack themida , trick use detect it easy (.Net) cần phần mềm để fix dump coi để biết
118 getlocaltime api - internalmodular
120 blocking server checks - block server check, cung co the nop ham call server check
124 setting software to Genuine and Activating program features - .Net
126 bypass server response method - .Net

132 crack license check - bai nay no chi dung call stack va phan tich cung kha on trong cac bai khac
134 registering username

136 prevent force close - quang trong vcl

140 reverse onion layer method - reverse onion method (cach hay)
143 using api monitor to extract saved login data - tim kiem noi key duoc luu
145 using call stack to activate - muc dich cua cai note nay la de check va so sanh ket qua :V
147 unpacking dotfuscator
149 serial phising using the dnspy debugger - noi chung la de ma cung khong kho :))
151 process explorer and disabled buttons - ************************* quang trong vcc
153 bypass loader protection - ************************* quang trong vcc
154 cracking trial license - ************************* quang trong vcc
155 patching dll file - ************************* quang trong vcc
158 bypassing turbo activate - bypass turboactivate.exe
163 api monitor analysis
164 tracing key file - crack by fake key method
168 data segment analysis - tim kiem trong data segment
172 using exceptions to locate patch -************************* bai nay phan tich chuan
179 bypass crc check using message breakpoint method
180 expire trial method
183 using SetWindowPos api to hide splash screen - hoi mu mo`
184 GetPrivateProfileString API - ************************* 
186 TracingGlobalVariables - ************************* 
187 diff tracing and GetSystemTimeAsFileTimeAPI
189 comment tracing method - cai nay rat la la.
190 api monitor file tracing and bypassing account login
194 antidebugger comment trace to crack first check - bypass anti debug  by hide debugg
196 register tracing to crack 2nd activation check
197 installing and detecting protector - confuser 1.x and confuserex 1.0
204 expire trial method - ************************* phãi coi, nêu ax = 0x1 mà không nhảy đúng hướng thì nên xem lại
205 bypassing anti tamper protection - bypass crc check
210 Using Reverse Onion Layer Method to remove Limitations on Edit and Save - ********* callstack -> reverse onion, set all bp -> run
211 removing nag banner ads by child process file - chan phan mem quan cao bang 1 symbol









- 1-55 se co bai` hoc dung set breakpoint on execution lo ma tim thang ngu
	+ (chua chac lo ma tim) set breakpoint on execution : set khi chuong trinh dang running, neu ta set breakpoint thuong thi ta k the step over duoc nhung khi set breakpoint on execution thi co the

- khi chúng ta đang tìm đường đi để check thì chúng ta phãi coi cái ram memory address (địa chỉ chạy lệnh)
	- khi chúng ta đang check bằng cách nhấn f8 thì đôi khi nó sẽ hiện running nhưng k thể thao tác , đó là lý do ta dùng hardware breakpoint
	- khi ta tìm ở ram memory address 6xxxxx.... mà chuyển tới address hệ thống 8xxx thì nên dừng ở hàm gọi gần nhất và press g để check các đường đi
	- 6xxxxxx... là thư viện  chúng ta có thể check ở memory map
	- thống thường là ta tìm ở phần code user 4xxxxx..
	- https://www.youtube.com/watch?v=D9hQu9fAmCs&list=PLFgDJNQkgnu9NilH9vjHtJC0mW4o7jegn&index=18&pp=gAQBiAQBsAQB
	
- tín hiệu ta đang debug đúng nơi là có nhiều jump và register thường là các thanh ghi tính toán eax ebx,esi .....
- thường thì đường đi ngắn nhất là sai
- khi đã crack chúng ta phãi đổi tên file về như củ vì có khả năng sẽ sinh lỗi vì các chức năng cần check name file để sử dụng :V trick lừa mấy ông debugger
- trick để trả về đúng giá trị là thay cả func đó với lệnh ta cần
	+ VD:   call 0x11412
		cmp eax,1
		je 0x11111
	+ ta cần eax = 1 và gọi hàm phãi trả về 1, thì ta chỉ cần sử cái hàm đấy  trả về 1 
		mov eax,1
		ret
		+ điều này giúp ta bypass mọi nơi mỗi khi call hàm này để check nó đều trả về 1
- trick xử lý crack
	+ nếu so sánh là ở bộ nhớ chúng ta nên vào hàm và xem giá trị nào thay đổi bộ nhớ đấy
		+ vì các giá trị dưỡi sẽ trích xuất dữ liệu từ bộ nhớ ra so sánh nên ta phãi vào hàm coi kĩ và sửa giá trị sao cho hợp lý
	+ nêu so sánh nhảy là thanh ghi với thanh ghi và số thì chúng ta sẽ kiếm hàm thay đổi trả về giá trị hoặc sửa jmp luôn cũng dc, đôi khi chúng ta vẫn nên kiểm tra vì kiểu j đoạn sau có thể check lại thanh ghi
- đôi khi programer sẽ lừa vì ta luôn theo dõi eax và cách để tránh bị lừa
	+ 204 expire trial method
	- thông thường crc check nó sẽ set giá trị ax ve 0x1
	+ nêu ax = 0x1 mà không nhảy đúng hướng thì chắc chắn là lệnh lừa 

- Cyclic Redundancy Check thường viết tắt là CRC, là thuật ngữ tiếng Anh trong kỹ thuật số, là phương pháp kiểm tra và phát hiện lỗi, được sử dụng trong các mạng số và thiết bị lưu trữ để phát hiện sự thay đổi tình cờ đối với dữ liệu được truyền đi hay lưu trữ.
	+ khi ta sửa dữ liệu và khiến trigger crc, nó sẽ dẫn ta tới bad message,  thông thường thì đây đc gọi là anti tamper protect
	+ bypass nó thì cứ jmp nó là dc :V tránh báo lỗi của nó thôi








mô phỏng crack
	- dung http analysis xem có action online không 
	- dùng api monitor xem có đọc file key không
		+ dựa vào việc này ta có thể method search string và tìm tới gần hơn nơi ta crack
		+ vd: tạo key file rồi khiến file đó confirmed là bypass
	- nếu các bước trên không có ta sẽ dùng các method khác để crack
	- nếu có ta theo dõi nhánh, comment, follow eax, global variable, hàm window api để crack thành công






mô phỏng
- để crack clear (crack toàn bộ mà k phãi từng phần) chúng ta phãi tìm cái register khiến chúng ta có bad message và sau đó tìm các lệnh khiến cho register đó thay đổi
	023 cracking mr bills  - (important)
- thông thường programer sẽ
	check format -> check value


- mổ ta deep crack
	+ họ sẽ tạo 1 hoặc nhiều func check và dùng lại nhiều lần
	+ nếu chúng ta crack surface thì chúng ta chỉ thay đổi giá trị check và dẫn dắt tới good message nhưng nêu chúng ta muốn deep crack chúng ta phãi đi qua phần check của nó và xem, khi chúng ta sửa thành công thì chúng ta sẽ crack toàn bộ mà không cần sửa các chức năng khác


try it
https://reverseengineering.stackexchange.com/questions/2796/find-a-string-that-i-entered-in-ollydbg


or al,1		- 2byte








Burp Suite
deep freeze
https://www.softwaretestinghelp.com/remote-access-software/





- ReadFile window API
	+ dữ liệu của file sẽ được lưu ở địa tri với biến lpNumberOfBytesRead
	+ nNumberOfBytesToRead : The maximum number of bytes to be read.



- .NET Deobfuscator
https://github.com/NotPrab/.NET-Deobfuscator
https://github.com/Patrick979/.NET-Deobfuscator
	- confuser 1.9
		+ de4dot
	- confuserex
		
			



